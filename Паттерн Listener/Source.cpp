// Например, в терминах ООП это могло бы выглядеть так.
struct Button;

// интерфейс, который реализуют все классы,
// объекты которые хотят подписаться на событие
// "кнопка нажата"
struct ButtonListener
{
	// метод, который будет вызываться, когда
	 // происходит событие "кнопка нажата"
	virtual void onButtonClick(Button * b, bool down) = 0;
	virtual ~ButtonListener() {}
};

// общий класс для кнопок
struct Button
{
	// метод позволяет подписать объект класс,
	// реализующего интерфейс ButtonListener
   // на событие "кнопка нажата"
	void subscribe(ButtonListener * bl);
};

// Этот же шаблон проектирования можно реализовать без наследования, виртуальных методов и интерфейсов при помощи указателей на функции.
// Решение с помощью указателей на функции :
struct Button;

// тип указателя на функцию, которая будет вызываться,
// когда событие "кнопка нажата"
typedef void(*ButtonProc)(Button *, bool, void *);

// общий класс для кнопок
struct Button
{
	// метод позволяет подписать объект функцию
	// типа ButtonProc на событие "кнопка нажата"
	void subscribe(ButtonProc bp, void * arg);
};